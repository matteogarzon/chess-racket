;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-advanced-reader.ss" "lang")((modname logic) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #t #t none #f () #f)))
(require racket/base)
(provide get-piece)
(provide piece?)
(provide piece-type)
(provide possible-pawn-moves)
(provide calculate-all-moves)
(provide piece-movement)
(provide piece-repeatable)
(provide move-piece)

;; NOTA PER LORIS E LEONARDO
; Per simplificare la logica a livello di array 2D, le pedine del giocatore locale sono state posizionate dalla parte dell'avversario (cosÃ¬ basta dire posizione 0 e 0 al posto di 7 e 7, ecc..)
; Quindi, a livello di UI bisogna cambiare l'ordine una volta che si mettono le pedine nella scacchiera visiva.

; Types of Moves
(define DIAGONAL-MOVES (list (make-posn 1 1) (make-posn 1 -1) (make-posn -1 1) (make-posn -1 -1)))
(define VERTICAL-MOVES (list (make-posn 1 0) (make-posn -1 0)))
(define HORIZONTAL-MOVES (list (make-posn 0 1) (make-posn 0 -1)))
(define KNIGHT-MOVES   (list (make-posn 2 1) (make-posn 2 -1) (make-posn -2 1) (make-posn -2 -1) (make-posn 1 2) (make-posn 1 -2) (make-posn -1 2) (make-posn -1 -2)))

(define KING-QUEEN-MOVES (append DIAGONAL-MOVES VERTICAL-MOVES HORIZONTAL-MOVES))
(define ROOK-MOVES (append VERTICAL-MOVES HORIZONTAL-MOVES))

;; DATA TYPES
; Piece is a structure:
;   (make-piece type movement repeatable player color)
; where:

; type is a string and can be one of the following:
; - King
; - Queen
; - Knight
; - Rook
; - Bishop
; - Piece

; player is a Number and one of the following:
; 1 = local player
; 2 = other player

; color is a String and one of the following;
; - Black
; - White

; movement is a list of posn (representing the types of movements)
; repeatable is a boolean
(define-struct piece [type movement repeatable player color] #:transparent)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; STARTING PIECES
; BLACK
(define BLACK-KING (make-piece "king" KING-QUEEN-MOVES false 1 "BLACK"))
(define BLACK-QUEEN (make-piece "queen" KING-QUEEN-MOVES true 1 "BLACK"))

(define BLACK-KNIGHT (make-piece "knight" KNIGHT-MOVES false 1 "BLACK"))
(define BLACK-ROOK (make-piece "rook" ROOK-MOVES true 1 "BLACK"))
(define BLACK-BISHOP (make-piece "bishop" DIAGONAL-MOVES true 1 "BLACK"))
(define BLACK-PAWN (make-piece "pawn" '(make-posn 0 1) false 1 "BLACK"))

; WHITES
(define WHITE-KING (make-piece "king" KING-QUEEN-MOVES false 2 "WHITE"))
(define WHITE-QUEEN (make-piece "queen" KING-QUEEN-MOVES true 2 "WHITE"))

(define WHITE-KNIGHT (make-piece "knight" KNIGHT-MOVES false 2 "WHITE"))
(define WHITE-ROOK (make-piece "rook" ROOK-MOVES true 2 "WHITE"))
(define WHITE-BISHOP (make-piece "bishop" DIAGONAL-MOVES true 2 "WHITE"))
(define WHITE-PAWN (make-piece "pawn" '(make-posn 0 1) false 2 "WHITE"))

; Board, with initial 
(define BOARD-VECTOR
  (vector
    (vector BLACK-ROOK BLACK-KNIGHT BLACK-BISHOP BLACK-QUEEN BLACK-KING BLACK-BISHOP BLACK-KNIGHT BLACK-ROOK)
    (vector BLACK-PAWN BLACK-PAWN BLACK-PAWN BLACK-PAWN BLACK-PAWN BLACK-PAWN BLACK-PAWN BLACK-PAWN)
    (vector 0 0 0 0 0 0 0 0)
    (vector 0 0 0 0 0 0 0 0)
    (vector 0 0 0 0 0 0 0 0)
    (vector 0 0 0 0 0 0 0 0)
    (vector WHITE-PAWN WHITE-PAWN WHITE-PAWN WHITE-PAWN WHITE-PAWN WHITE-PAWN WHITE-PAWN)
    (vector WHITE-ROOK WHITE-KNIGHT WHITE-BISHOP WHITE-QUEEN WHITE-KING WHITE-BISHOP WHITE-KNIGHT WHITE-ROOK)))


; in-bounds : Posn -> Boolean
; checks if position is inside chess board
; header: (define (in-bounds? (make-posn 5 5) #true))
(define (in-bounds? position)
  (cond
    [(and (and (>= (posn-x position) 0) (<= (posn-x position) 7)) (and (>= (posn-y position) 0) (<= (posn-y position) 7))) #true]
    [else #false]))

(check-expect (in-bounds? (make-posn 8 8)) #false)
(check-expect (in-bounds? (make-posn 7 8)) #false)
(check-expect (in-bounds? (make-posn 0 0)) #true)
(check-expect (in-bounds? (make-posn 5 4)) #true)

; move-piece : Posn Posn -> void
; moves piece from original posn position to new position, and mutates BOARD-VECTOR accordingly
(define (move-piece current-posn new-posn)
  (begin
    (set-piece new-posn)
    (set-null current-posn)))

;; HELPER FUNCTIONS FOR 'move-piece'
; set-piece: Posn -> void
(define (set-piece position)
  (vector-set! (vector-ref BOARD-VECTOR (posn-y position)) (posn-x position) (get-piece position)))

; set-null : Posn -> void
(define (set-null position)
    (vector-set! (vector-ref BOARD-VECTOR (posn-y position)) (posn-x position) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; HELPER FUNCTIONS
; get-piece : Posn -> Maybe<Piece>
(define (get-piece position)
  (vector-ref (vector-ref BOARD-VECTOR (posn-y position)) (posn-x position)))

; my-piece? : Piece -> Boolean
; checks if piece is of the local player, based on the player number on piece
(define (my-piece? piece)
  (cond
    [(equal? piece-player 1) #true]
    [else #false]))

; is-there-piece? : Posn -> Boolean
; checks whether there's a piece in the specified position
(define (is-there-piece? position)
  (cond
    [(piece? (get-piece position)) #true]
    [else #false]))

(check-expect (is-there-piece? (make-posn 1 1)) #true)
(check-expect (is-there-piece? (make-posn 5 5)) #false)
(check-expect (is-there-piece? (make-posn 7 7)) #true)

(define (is-there-opponent-piece? position)
  (cond
    [(and (in-bounds? position) (piece? (get-piece position)) (= 2 (piece-player (get-piece position)))) #true]
    [else #false]))

(check-expect (is-there-opponent-piece? (make-posn 1 1)) #false)
(check-expect (is-there-opponent-piece? (make-posn 5 5)) #false)
(check-expect (is-there-opponent-piece? (make-posn 7 7)) #true)
(check-expect (is-there-opponent-piece? (make-posn 8 8)) #false)


; move-one-forward? : Posn -> Boolean
(define (move-one-forward? position)
  (local [(define new-posn (make-posn (posn-x position) (add1 (posn-y position))))]
    (cond
      [(and (not (is-there-piece? new-posn)) (in-bounds? new-posn)) #true]
      [else #false])))

(check-expect (move-one-forward? (make-posn 1 2)) #true)
(check-expect (move-one-forward? (make-posn 7 6)) #false)

(define (move-one-forward position)
  (make-posn (posn-x position) (add1(posn-y position))))

; move-two-forward? : Posn -> Boolean
; can only move if there is not a piece and is at starting point!
(define (move-two-forward? position)
  (local [(define new-posn (make-posn (posn-x position) (+ 2 (posn-y position))))]
    (cond
      [(and (not(is-there-piece? new-posn)) (= 1 (posn-y position)) (in-bounds? new-posn)) #true]
      [else #false])))

(check-expect (move-two-forward? (make-posn 1 1)) #true)
(check-expect (move-two-forward? (make-posn 1 2)) #false)
(check-expect (move-two-forward? (make-posn 7 5)) #false)

; move-left-diagonal? : Posn -> Boolean
(define (move-left-diagonal? position)
  (cond
    [(not(is-there-opponent-piece? (make-posn (sub1(posn-x position)) (add1(posn-y position))))) #false]
    [else #true]))

(check-expect (move-left-diagonal? (make-posn 2 2)) #false)
(check-expect (move-left-diagonal? (make-posn 4 3)) #false)
(check-expect (move-left-diagonal? (make-posn 5 5)) #true)

(define (move-left-diagonal position)
  (make-posn (sub1(posn-x position)) (add1(posn-y position))))

; move-right-diagonal? : Posn -> Boolean
(define (move-right-diagonal? position)
  (cond
    [(not(is-there-opponent-piece? (make-posn (add1(posn-x position)) (add1(posn-y position))))) #false]
    [else #true]))

(define (move-right-diagonal position)
  (make-posn (add1(posn-x position)) (add1(posn-y position))))

;;;;;;;;;;;;;;;
;; PAWN ONLY ;;
;;;;;;;;;;;;;;;

; possible-pawn-moves : List<Posn> Posn -> List<Posn>
; returns list of possible moves for pawns
; function calls itself

(define (possible-pawn-moves possible-moves current-position)
  (local ((define MOVE-ONE-FORWARD (move-one-forward current-position))
    (define MOVE-TWO-FORWARD (move-one-forward MOVE-ONE-FORWARD))
    (define MOVE-LEFT-DIAGONAL (move-left-diagonal current-position))
    (define MOVE-RIGHT-DIAGONAL (move-right-diagonal current-position)))
    
  (cond
    [(and (move-one-forward? current-position) (not(member MOVE-ONE-FORWARD possible-moves))) (possible-pawn-moves (append possible-moves (list MOVE-ONE-FORWARD)) current-position)]
    [(and (move-two-forward? current-position) (not(member MOVE-TWO-FORWARD possible-moves))) (possible-pawn-moves (append possible-moves (list MOVE-TWO-FORWARD)) current-position)]
    [(and (move-right-diagonal? current-position) (not(member MOVE-RIGHT-DIAGONAL possible-moves))) (possible-pawn-moves (append possible-moves (list MOVE-RIGHT-DIAGONAL)) current-position)]
    [(and (move-left-diagonal? current-position) (not(member MOVE-LEFT-DIAGONAL possible-moves))) (possible-pawn-moves (append possible-moves (list MOVE-LEFT-DIAGONAL)) current-position)]
    [else possible-moves])))

; Examples (use BOARD-VECTOR as reference)
(check-expect (possible-pawn-moves '() (make-posn 3 1)) (list (make-posn 3 2) (make-posn 3 3))) ; starting position
(check-expect (possible-pawn-moves '() (make-posn 3 2)) (list (make-posn 3 3)))
(check-expect (possible-pawn-moves '() (make-posn 5 5)) (list (make-posn 6 6) (make-posn 4 6)))

;;;;;;;;;;;;;;;;;;;
;; NON-PAWN ONLY ;;
;;;;;;;;;;;;;;;;;;;

; calculate-move : List<Posn>, Posn, Boolean -> List<Posn>
; calculates possible moves based on single 'move' and 'current position'
; header:

; template:

(define (calculate-move new-moves move current-position is-repeatable)
  (local [(define new-posn (make-posn (+ (posn-x move) (posn-x current-position)) (+ (posn-y move) (posn-y current-position))))]
    (cond
      [(and (in-bounds? new-posn) is-repeatable (or (is-there-opponent-piece? new-posn) not((is-there-piece? new-posn)))) (calculate-move (append new-moves (list new-posn)) move new-posn is-repeatable)]
      [(and (in-bounds? new-posn) (not is-repeatable) (or (is-there-opponent-piece? new-posn) not((is-there-piece? new-posn)))) (append new-moves (list new-posn))]
      [else new-moves])))

; examples:
(check-expect (calculate-move '() (make-posn 1 0) (make-posn 2 3) true) (list (make-posn 3 3) (make-posn 4 3) (make-posn 5 3) (make-posn 6 3) (make-posn 7 3)))
(check-expect (calculate-move '() (make-posn 2 1) (make-posn 2 3) false) (list (make-posn 4 4))) ;; CHECK-EXPECT

; calculate-all-moves : Posn, List<Posn>, Boolean -> List<List<Posn>>
; from position and type of movement of piece, returns possible moves
; used for non-pawn pieces
; header: (define (possible-moves (make-posn 1 0) KING-QUEEN-MOVES true) '((posn 1 2) (posn 1 3)))

; template:

(define (calculate-all-moves current-position movements is-repeatable)
 (map (lambda (move) (calculate-move '() move current-position is-repeatable)) movements))

; examples:
(calculate-all-moves (make-posn 3 1) DIAGONAL-MOVES true)